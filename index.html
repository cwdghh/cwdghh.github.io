<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="吃完的贝壳">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="吃完的贝壳">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>吃完的贝壳</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">吃完的贝壳</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">欢迎来到陈蔚的博客哦！</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/14/%E3%80%8A%E6%9D%B0%E7%BD%97%E5%BE%B7%E7%9A%84%E6%B8%B8%E6%88%8F%E3%80%8B%E7%BF%BB%E8%AF%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="陈蔚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吃完的贝壳">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/14/%E3%80%8A%E6%9D%B0%E7%BD%97%E5%BE%B7%E7%9A%84%E6%B8%B8%E6%88%8F%E3%80%8B%E7%BF%BB%E8%AF%91/" class="post-title-link" itemprop="url">《杰罗德的游戏》翻译</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-14 21:33:50" itemprop="dateCreated datePublished" datetime="2020-11-14T21:33:50+08:00">2020-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-15 10:37:26" itemprop="dateModified" datetime="2020-11-15T10:37:26+08:00">2020-11-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6/" itemprop="url" rel="index">
                    <span itemprop="name">读书</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="《杰罗德的游戏》翻译"><a href="#《杰罗德的游戏》翻译" class="headerlink" title="《杰罗德的游戏》翻译"></a>《杰罗德的游戏》翻译</h1><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>杰西能够听到屋子的后门在屋旁十月微风的吹拂下发出无规则的、轻轻的撞击声。在秋天，门框总是会变得受潮突出，因此你总得猛地用力才能把门好好关紧。这次他们两个人都忘了这事儿。杰西想，在他们两个完全沉浸在“游戏”中前，应该叫杰罗德去把后门好好关上，否则这撞击声非把她逼疯不可。然后，她忽然想到，考虑到现在的情况，那将变得多可笑。那将把整片氛围都毁掉。</p>
<p><em>什么氛围？</em></p>
<p>这可真是个好问题。当杰罗德转动在第二个手铐锁孔中的钥匙时，当她听见手表走动的滴答声从左耳传来时，杰西意识到至少对她来说，这氛围可根本不值得保留。当然了，这就是为什么她一下子就注意到了没有好好关紧的门。对她来说，捆绑“游戏”带来的性刺激并没有持续太久。</p>
<p>然而无论如何，杰罗德可不是这么想的。此刻，他只穿着一条Jockey牌的短裤，杰西甚至不用抬头去看他的脸就能知道他（对于捆绑“游戏”）的兴趣猛烈如初。</p>
<p><em>这太愚蠢了，</em>她想到，但是愚蠢可概括不了整件事。事实上，这也让人觉得有点害怕。尽管她不想承认，但事实如此。</p>
<p>“杰罗德，为什么我们就不能把这事儿抛在一边？”</p>
<p>他犹豫了一下，微微皱了一下眉，然后仍旧穿过房间走向到浴室门旁边的写字桌。在他走动的过程中，他的神情又恢复如初。杰西从她躺的位置看着他，她的手臂展开着，使她看着有点像是在电影《金刚》中被锁起来等待着那只猩猩来营救的菲伊·雷。此刻，她的手腕正被两副手铐紧紧地缚在桃花心木制的床柱上。锁链只给每只手留下了六英寸的活动空间。一点儿也不多。</p>
<p>他把钥匙放在写字桌上——分针发出了两下滴答声，杰西觉得她的耳朵在这个周三下午似乎格外灵敏——然后重新转向她。自湖面反射而来的日光正在他的头上以及卧室洁白的天花板上舞动。</p>
<p>“你觉得怎么样？我觉得这事儿对我来说已经没有什么吸引力了。”事实上，它从刚开始就没多少吸引力，她想着却没有说出来。</p>
<p>杰罗德慢慢咧开嘴笑了。在他那如乌鸦羽毛般乌黑的头发下，是一张粉皮肤的面孔，而他那咧嘴笑总是给她带来一些她没有特别在意的感觉。她并不能够把那种感觉形容得太清楚，但是——</p>
<p><em>得了吧，你当然可以形容清楚。那种咧嘴笑让他看上去愚蠢透顶。你甚至可以清楚得感觉到他的嘴每咧开一英寸，他的智商就得往下掉十点。当嘴咧到最大程度时，你那战无不胜的法人律师丈夫看着就好像是一个正在休假的本地精神疾病中心看门人。</em></p>
<p>那听上去很残忍，但却并不是毫无根据的。但你怎么能告诉你的丈夫说，将近二十年来，每次他咧嘴笑的时候看上去都像是个智力障碍患者呢？答案很简单，你不能。当然，杰罗德的笑容和他的咧嘴笑完全不是一码事儿。他的笑容很讨人喜欢——杰西猜测正是那温暖的、使人心情愉悦的笑容才让她决定和他一起出门旅游。这笑容总是让她想起自己的父亲晚饭前，呷着掺了奎宁水的杜松子酒时，跟家人们分享今日趣事时的笑容。</p>
<p>然而，现在在杰罗德脸上的可不是笑容。这是他的咧嘴笑——一个他只为了三种情况特地保留的笑容版本。她隐隐感觉到，对于杰罗德来说，这咧嘴笑让他感到自己像是一匹狼，甚至是有点海盗的痞气。然而从杰西的角度看来，特别是考虑到她正双手被锁地躺着、全身上下只有一条比基尼短裤，这笑蠢得不行。不……不是蠢，而是智力障碍。毕竟，杰罗德并不是那种男士杂志上漫不经心的探索者，而这些杂志曾帮助他在那孤独的、过度肥胖青春期进行过无数次射精。如今，他已经是一个有着粉色大脸的律师，而他的头发正越来越薄，不断朝着完全的秃顶前进。他的短裤此刻正因为下身的坚挺而变形。当然，这变形的幅度并不大。</p>
<p>无论如何，他勃起的大小可不是现在恼人的事情。真正恼人的事情是他脸上那愚蠢的咧嘴笑。那笑容一点儿也没变，这说明杰罗德把她之前的话当作了彻彻底底的耳旁风。她本就该发出抗议；毕竟，那就是捆绑“游戏”的规则。</p>
<p>“杰罗德？我是认真的。”</p>
<p>那咧嘴笑变得更大了。他那令人不讨厌的律师牙齿又多露出来了几颗；他的智商也随之又下滑了二十到三十点。并且，他仍旧没把她的话当回事儿。</p>
<p><em>你确定吗？</em></p>
<p>她确定。虽然她并不能把他看得透透彻彻——她认为十七年的婚姻还远不足以让她对他的了解达到这种程度——但她认为大多数时候她都能看穿他心里正在想什么。杰西想，要是她不能做到这一点，那么他们的婚姻早该玩完了。</p>
<p><em>如果你真能看穿他的大部分想法，嘟嘟，那么为什么他一点也不清楚你在想什么呢？为什么他不明白这根本不是他们情趣游戏中的一个新玩法呢？</em></p>
<p>如今，轮到杰西微微皱眉了。她经常听见自己脑内的声音——她猜每个人都是这样的，尽管人们并不常提到这些声音，就像他们不常提到自己的肠道状况一样——并且这些声音中的大部分对她来说都是老朋友了，就像是卧室里使用的拖鞋一样令人舒适。然而，这次她脑内的声音却不是她熟悉的那几个……并且这声音一点儿也不让人感到舒适。那声音强而有力，听起来年轻且有活力。同时，那声音听着极不耐烦。如今，那声音又发言了，回答着自己之前提出来的问题。</p>
<p><em>并不是他不清楚你在想什么；只是有些时候，嘟嘟，他并不想弄清楚你在想什么。</em></p>
<p>“杰罗德，讲真的——我今天真的没心情搞这事儿。把钥匙拿过来然后打开我手上的手铐吧。我们可以做点什么别的。如果你想要的话，我可以在你身上做。或者，如果你愿意，你可以把你的手放在脑后然后让我来干你，你知道的，用另外的方式。”</p>
<p><em>你确定你真的想要那么做吗？她脑中的新声音问道。你真的真的确定想要和那个男人做爱吗？</em></p>
<p>杰西闭上了她的眼睛，好像那样就能叫那声音闭嘴似的。当她重新睁开眼睛时，杰罗德正站在床根，他内裤前的耸起就好像是一条船的船头。呃，好吧……大概只能算的上是某种儿童的玩具船罢了。他的笑脸咧得更大了，两侧剩下的几颗牙齿也露了出来——那些镶金的牙齿。杰西意识到她不仅仅是不喜欢这弱智的笑容了；她鄙视它。</p>
<p>“我<em>会</em>帮你松绑的 ……如果你愿意做个好姑娘。你愿意做个好姑娘吗，杰西？”</p>
<p><em>陈词滥调</em>，那个新声音评价道。<em>彻头彻尾的陈词滥调。</em></p>
<p>他把手指插进自己短裤松紧带中，这姿势让他看上去像一个荒唐滑稽的牛仔杀手。一脱离他的掌握，Jockey牌的内裤就轻而易举地滑下。啊哈，它就这么暴露在那里了。这个并不是她年轻的时候在《Fanny Hill》杂志上曾经看到过的那粗壮到令人生畏的“做爱引擎”，而是一个小小温驯的、粉色而包皮未割的小玩意儿；它在完全勃起的情况下也只有并不引人注目的五英寸长。两到三年前，在她某次前往波士顿的旅途中，她曾看过一部叫做《建筑师的肚子》的电影。她想到，<em>好的，那么我现在正在看“律师的阴茎”。</em>她必须咬住自己脸颊内侧的软肉才能控制住自己不笑出声来。在这种情况下笑出声来可不是什么明智的行为。</p>
<p>之后，一个想法闯入她的脑海，并消除了她所有想笑的冲动。这想法是这样的：他并不认为她说那话是认真的，因为，对他来说，杰西·马霍特·博林盖姆，杰罗德的妻子，马蒂与威尔的姐姐，汤姆和萨利的女儿，不是任何人母亲的女人，根本就不在他的眼前。自钥匙在手铐的锁孔中发出小小的、金属制的咔嚓声起，对于杰罗德来说她就不在他眼前了。曾经在杰罗德青年时期的那些男士“冒险”杂志如今已经变成了他抽屉最底部的一叠色情刊物。在那些杂志上，总有全身上下除了珍珠项链以外一丝不挂的女人跪倒在熊皮地毯上，在她们身后总有挺着雄健下身（让杰罗德的那玩意儿相形见绌）的男性拿着性爱器具干她们。在这些杂志的后表面，在那些写着“和我聊骚”的电话广告中间，是一些生理构造精良的充气娃娃广告——充气娃娃是一个杰西之前想都没有想过的奇怪概念。如今，她正带着启示性的惊异想着那些充气的娃娃，想着她们粉色的皮肤，她们没有缝合线的卡通身体以及她们那平平无奇的面孔。她感到自己的内部忽然被一束并不是恐慌——并不完全是——的光束照亮，并且这束光照明的真相比这愚蠢的”游戏“要吓人的多——他们正在湖畔的一个夏季别墅中玩这捆绑”游戏“，可是游客熙熙攘攘的夏季早已过去。</p>
<p>但是这些想法一点儿也没有影响到她敏锐的听觉。现在，杰西听到的是在遥远森林中传来的链锯声——她估计至少有五英里远。更近一点呢？在Kashawakamak湖心那里，一只迟迟没有启程南飞的潜鸟的疯狂叫声正在十月湛蓝的天空里回荡。更近一点，自湖北岸的某地，犬吠不断传来。那是一种多么丑陋的、像是棘轮般的声音啊，但是杰西听着却有一种莫名的心安。这狗叫声至少表明在十月中旬左右，仍有带着猎犬的猎人在这附近。剩下的，就只有那未关好的门的撞击声了，那门撞在受潮的门框上，就好像是腐烂牙床上摇摇晃晃的黄牙一样令人恶心。她感觉如果她再听下去，这撞击声非让她发疯不可。</p>
<p>杰罗德，如今除了他的眼镜以外一丝不挂的杰罗德，跪在床上并慢慢爬向她。他的眼睛闪闪发光。</p>
<p>杰西忽然意识到他眼中的这种光芒正是促使她在最初的好奇满足后仍旧继续陪着杰罗德玩这”游戏“的原因。她已经好几年没有在杰罗德看她时感受到他眼中如此的火热光芒了。老实说，她一点也不难看——虽然年龄渐长，她仍想办法保持着自己的体重与曼妙的身材——然而杰罗德对她的”性趣“却仍是逐渐减少。她意识到烈酒是罪魁祸首之一——比起他们刚结婚那会儿，他喝的多多了——但是她认为烈酒并不是所有的原因。那句关于男女上床久了就会彼此厌烦的古老谚语是怎么说的来着？根据她在《English Lit 101》上看到的浪漫情诗来看，那句古老的谚语一点也不对，可是自从大学时期开始她就已经发现关于生活的有些真相是约翰·济慈与珀西·雪莱从未写过的。因为当然了，这两位诗人去世时的年纪比如今的她与杰罗德要小得多。</p>
<p>不过，上述的这些在现在这个时间与地点显得一点儿也不重要。真正可能重要的是，出于对杰罗德眼中火热光芒的渴望，杰西准许这种”游戏“的时间比她自己真正想要的要长的多。那光芒让她感觉自己仍旧年轻貌美，充满诱惑力。可是……</p>
<p><em>……可是如果你真的认为他是因为看到你眼中才闪烁着那种光芒的话，你就大错特错了小姐，嘟嘟。又或者是你一直在骗你自己。或许，现在你可以好好考虑一下你是否要继续忍受这种羞辱了。因为难道这不就是你现在的所有体会吗？只有羞辱而已？</em></p>
<p>她长长地叹了一口气。是的，只有羞辱而已。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/15/%E3%80%8A%E7%BA%A2%E6%A5%BC%E6%A2%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="陈蔚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吃完的贝壳">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/15/%E3%80%8A%E7%BA%A2%E6%A5%BC%E6%A2%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">《红楼梦》读书笔记</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-15 09:46:36 / 修改时间：11:29:53" itemprop="dateCreated datePublished" datetime="2020-06-15T09:46:36+08:00">2020-06-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6/" itemprop="url" rel="index">
                    <span itemprop="name">读书</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="《红楼梦》读书笔记"><a href="#《红楼梦》读书笔记" class="headerlink" title="《红楼梦》读书笔记"></a>《红楼梦》读书笔记</h1><p>一首诗词，阅尽人生悲凉：</p>
<blockquote>
<p>陋室空堂，当年笏满床。</p>
<p>衰草枯杨，曾为歌舞场。</p>
<p>蛛丝儿结满雕梁，绿纱儿今又糊在蓬窗上。</p>
<p>说什么脂正浓、粉正香，如何两鬓又成霜？</p>
<p>昨日黄土陇头送白骨，今宵红灯帐底卧鸳鸯。</p>
<p>金满箱，银满箱，转眼乞丐人皆谤。</p>
<p>正叹他人命不长，那知自己归来丧！</p>
<p>训有方，保不定日后作强梁。</p>
<p>择膏粱，谁承望流落在烟花巷！</p>
<p>因嫌纱帽小，致使锁枷扛。</p>
<p>昨怜破袄寒，今嫌紫袍长。</p>
<p>乱哄哄，你方唱罢我登场，反认他乡是故乡。</p>
<p>甚荒唐，到头来都是为他人作嫁衣裳。</p>
</blockquote>
<h2 id="重要人物梳理"><a href="#重要人物梳理" class="headerlink" title="重要人物梳理"></a>重要人物梳理</h2><p><strong>第一代</strong></p>
<p>宁国公、荣国公</p>
<p><strong>第二代</strong></p>
<p>贾代化、贾代善、贾母</p>
<p><strong>第三代</strong></p>
<p>宁国府：</p>
<p>贾敷：早死，与故事无关；</p>
<p>贾敬：贾代化之子，出场次数少，但是重要；</p>
<p>荣国府：</p>
<p>贾赦：；</p>
<p>邢夫人：贾赦之妻；</p>
<p>贾政：名字有暗喻；</p>
<p>王夫人：贾政之妻，贾宝玉之母；</p>
<p>贾敏：林黛玉之母；</p>
<p><strong>第四代</strong></p>
<p>宁国府：</p>
<p>贾珍：贾敬之子；</p>
<p>尤氏：贾珍之妻；</p>
<p>惜春：贾珍之妹；</p>
<p>荣国府：</p>
<p>贾琏：贾赦之子，娶了王熙凤；</p>
<p>王熙凤：女强人；</p>
<p>迎春：贾赦之女；</p>
<p>贾珠：贾政第一子，读书认真但早死；</p>
<p>李纨：贾珠之妻，金陵十二钗之一，妇德的代表；</p>
<p>元春：贾政之女，在正月初一出生，做了贵妃；</p>
<p>贾宝玉：贾政之子，含玉而生，吃女子的胭脂；</p>
<p>探春：贾政与赵姨娘之女；</p>
<p><strong>第五代</strong></p>
<p>宁国府：</p>
<p>贾蓉：贾珍之子，重要人物；</p>
<p>荣国府：</p>
<p>贾兰：李纨之子，后来重新考取进士做官；</p>
<hr>
<p>对于王熙凤的描写：</p>
<blockquote>
<p>彩绣辉煌，恍若神妃仙子。头上戴着金丝八宝攒珠髻，绾着朝阳五凤挂珠钗；项下盘着赤金盘螭缨络圈；裙边系着豆绿宫绦双鱼比目玫瑰佩；身上穿着缕金百蝶穿花大红洋缎穿福袄；外罩五彩刻丝石青银鼠褂；下罩翡翠撒花洋绉裙。</p>
<p>一双丹凤三角眼，两弯柳叶吊梢眉。身量苗条，体格风骚。粉面含春威不露，丹唇未启笑先闻。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/19/CS231N-Assignment1-Two_Layer_Net/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="陈蔚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吃完的贝壳">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/19/CS231N-Assignment1-Two_Layer_Net/" class="post-title-link" itemprop="url">CS231N-Assignment1-Two_Layer_Net</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-02-19 13:11:44 / 修改时间：15:26:32" itemprop="dateCreated datePublished" datetime="2020-02-19T13:11:44+08:00">2020-02-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/CS231N/" itemprop="url" rel="index">
                    <span itemprop="name">CS231N</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CS231N-Two-Layer-Net"><a href="#CS231N-Two-Layer-Net" class="headerlink" title="CS231N-Two_Layer_Net"></a>CS231N-Two_Layer_Net</h1><blockquote>
<p>Two_Layer_Net是CS231N中Assignment1的第四个习题。在这个习题中，我们需要实现一个两层全连接层的神经网络来完成分类任务，并在CIFAR-10数据集上完成测试。</p>
<p>本次练习的重点在于对简单的神经网络有一个初步的了解，在之后的练习中我们会更详细地操作。</p>
</blockquote>
<h2 id="具体的代码实现。"><a href="#具体的代码实现。" class="headerlink" title="具体的代码实现。"></a>具体的代码实现。</h2><p>这里神经网络的数学原理并没有之前的Softmax或SVM那么复杂就不再赘述，而代码用简单的矩阵乘法也容易。在接下来的代码中，我们希望做一个两层的全连接神经网络。这个网络有$N$个训练数据，每个训练数据的维度为$D$，然后有两个维度为$H$的全连接层，最后是要实现$C$个的分类。</p>
<p>我们训练这么网络时使用之前写过的Softmax作为损失函数，并用L2范数对权重矩阵进行正则化。这个神经网络在每个全连接层后加上一个非线性的ReLU层（仅使用线性层得到的结果也是线性的，因而表达能力不足；同时，这也是模拟人类神经元之间信号传递的形式——达到阈值才可激活）。</p>
<p>概括来讲我们的神经网络结构如下：</p>
<p><strong>input - fully connected layer - ReLU - fully connected layer - softmax</strong></p>
<p>我们直接上代码：</p>
<h3 id="neural-net-py"><a href="#neural-net-py" class="headerlink" title="neural_net.py"></a>neural_net.py</h3><p>在类TwoLayerNet中，我们先给出定义新的实例时需要的三个输入：</p>
<p>Input:</p>
<ul>
<li>input_size: The dimension D of the input data.</li>
<li>hidden_size: The number of neurons H in the hidden layer.</li>
<li>output_size: The number of classes C.</li>
</ul>
<p>已经给出的代码帮我们完成了初始化的操作，为了防止回归无法进行，我们将权重矩阵初始化为限定大小的随机数；然后简单起见，我们将偏差（bias）项全部初始化为零。</p>
<p>接下来是作业的第一个部分，先给出输入输出：</p>
<p>Inputs:</p>
<ul>
<li>X: Input data of shape (N, D). Each X[i] is a training sample.</li>
<li>y: Vector of training labels. y[i] is the label for X[i]. This parameter is optional; if it isn’t passed then we only return scores, and if it’s passed then we instead return the loss and gradients.</li>
<li>reg: Regularization strength.</li>
</ul>
<p>我们要实现方法.loss():</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(self, X, y=None, reg=<span class="number">0.0</span>)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"># 首先我们从self中取出权重矩阵和偏差项</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    W1, b1 = self.params[<span class="string">'W1'</span>], self.params[<span class="string">'b1'</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    W2, b2 = self.params[<span class="string">'W2'</span>], self.params[<span class="string">'b2'</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    scores = <span class="literal">None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    N, D = X.shape <span class="comment"># 定义一些需要用到的数字</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    hidden_1 = X.dot(W1) + b1 <span class="comment"># 这是全连接层</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    hidden_1[hidden_1&lt;<span class="number">0</span>] = <span class="number">0.0</span> <span class="comment"># 这是ReLU层</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    scores = hidden_1.dot(W2) + b2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> y <span class="keyword">is</span> <span class="literal">None</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> scores</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    loss = <span class="literal">None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    exp_scores = np.exp(scores)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    softmax = exp_scores/np.sum(exp_scores, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    loss = -np.sum(np.log(softmax[np.arange(N), y]))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    loss = loss/N + reg*(np.sum(W1*W1) + np.sum(W2*W2)) <span class="comment"># 加上正则化项</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    grads = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"># 以下计算梯度的过程建议自己像前几个练习一样求偏导得到结果，然后尝试进行矢量化的快速计算。无论如何链式法则总是很有用的。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    dscores = softmax</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    dscores[np.arange(N), y] -= <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    dscores /= N</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    grads[<span class="string">'b2'</span>] = np.sum(dscores, axis=<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    grads[<span class="string">'W2'</span>] = np.dot(hidden_1.T, dscores) + <span class="number">2</span>*reg*W2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    dhidden_1 = np.dot(dscores, W2.T)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    grads[<span class="string">'b1'</span>] = np.sum(dhidden_1, axis=<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    grads[<span class="string">'W1'</span>] = np.dot(X.T, dhidden_1) + <span class="number">2</span>*reg*W1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> loss, grads</span></pre></td></tr></table></figure>
<p>接下来，为了训练神经网络，我们将会使用随机梯度下降（SGD）的方法。先给出输入输出：</p>
<p>Inputs:</p>
<ul>
<li>X: A numpy array of shape (N, D) giving training data.</li>
<li>y: A numpy array of shape (N, ) giving training labels.</li>
<li>X_val: A numpy array of shape (N_val, D) giving validation data.</li>
<li>y_val: A numpy array of shape (N_val, ) giving validation labels.</li>
<li>learning_rate: Scalar giving learning rate for optimation.</li>
<li>learning_rate_decay: Scalar giving factor used to decay the learning rate after each epoch.</li>
<li>reg: Scalar giving regularization strength.</li>
<li>num_iters: Number of steps to take when optimizing.</li>
<li>batch_size: Number of training examples to use per step.</li>
<li>verbose: boolean; if true print progress during optimization.</li>
</ul>
<p>完成方法.train():</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span><span class="params">(self, X, y, X_val, y_val,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                learning_rate=<span class="number">1e-3</span>, learning_rate_dacay=<span class="number">0.95</span>,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                reg=<span class="number">5e-6</span>, num_iters=<span class="number">100</span>,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                batch_size=<span class="number">200</span>, verbose=False)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    num_train = X.shape[<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    iterations_per_epoch = max(num_train/batch_size, <span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    loss_history = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    train_acc_history = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    val_acc_history = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> it <span class="keyword">in</span> range(num_iters):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        X_batch = <span class="literal">None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        y_batch = <span class="literal">None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># 首先用随机数取出所用的下标，replace=True时我们会得到不重复的数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        index = np.random.choice(np.arange(num_train), batch_size, replace=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        X_batch = X[index, :]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        y_batch = y[index]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        loss, grads = self.loss(X_batch, y_batch)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        loss_history.append(loss)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># 接下来更新参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        self.params[<span class="string">'W1'</span>] -= learning_rate*grads[<span class="string">'W1'</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        self.params[<span class="string">'b1'</span>] -= learning_rate*grads[<span class="string">'b1'</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        self.params[<span class="string">'W2'</span>] -= learning_rate*grads[<span class="string">'W2'</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        self.params[<span class="string">'b2'</span>] -= learning_rate*grads[<span class="string">'b2'</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> verbose <span class="keyword">and</span> it%<span class="number">100</span>==<span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            print(<span class="string">'iteration %d / %d: loss %f'</span> % (it, num_iters, loss))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> it%iterations_per_epoch==<span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">            train_acc = (self.predict(X_batch)==y_batch).mean()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">            val_acc = (self.predict(X_val)==y_val).mean()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">            train_acc_history.append(train_acc)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">            val_acc_history.append(val_acc)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">            learning_rate *= learning_rate_decay</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        <span class="string">'loss_history'</span>: loss_history,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">        <span class="string">'train_acc_history'</span>: train_acc_history,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">        <span class="string">'val_acc_history'</span>: val_acc_history,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr></table></figure>
<p>在上述过程中我们已经用到了一个没有完成的方法.predict():</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(self, X)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    y_pred = <span class="literal">None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    y_pred = np.argmax(self.loss(X), axis=<span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> y_pred</span></pre></td></tr></table></figure>
<p>接下来的练习就是和之前类似的调参过程了，这里就不再赘述。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本次练习中，我们完成了一个简单的二层全连接神经网络——当然，我们此时用的方法还是比较原始的、灵活性较差的，在接下来的练习中，我们将会学着分别完成每一层的函数以达到方便组合的目的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/12/CS231N-Assignment1-SVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="陈蔚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吃完的贝壳">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/12/CS231N-Assignment1-SVM/" class="post-title-link" itemprop="url">CS231N-Assignment1-SVM</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-12 10:39:02" itemprop="dateCreated datePublished" datetime="2020-02-12T10:39:02+08:00">2020-02-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-08 21:20:48" itemprop="dateModified" datetime="2020-04-08T21:20:48+08:00">2020-04-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/CS231N/" itemprop="url" rel="index">
                    <span itemprop="name">CS231N</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CS231N-SVM"><a href="#CS231N-SVM" class="headerlink" title="CS231N-SVM"></a>CS231N-SVM</h1><blockquote>
<p>SVM是CS231N中Assignment1的第二个习题，是Support Vector Machine（支持向量机）的简称。SVM致力于寻找一个对学习样本的最大边距超平面。</p>
<p>本次练习的重点在于完成多分类任务的支持向量机算法，并使用SGD进行优化操作。</p>
</blockquote>
<h2 id="线性SVM的损失函数"><a href="#线性SVM的损失函数" class="headerlink" title="线性SVM的损失函数"></a>线性SVM的损失函数</h2><p>假设一共使用了$m$个训练样本，其中第$i$个训练样本的对$i$个类别的得分分别为$(v_{i,1},v_{i,2},\dots,v_{i,n})$，且其标签类别为$y_i$，则所求损失函数为：</p>
<script type="math/tex; mode=display">Loss=\displaystyle\sum_{i=1}^{m}{1(j\not=y_i)max\{0,v_{i,j}-v_{i,y_i}+1\}}</script><p>使用这种损失函数能够要求其余类别的得分需要比目标项的得分都低一定的值（这里选择的是1），从而达到了SVM的目的。</p>
<p>以下我们再来简单地计算一下梯度：</p>
<script type="math/tex; mode=display">
\frac{\partial Loss}{\partial v_{i,j}}=\begin{cases}-k,j=y_i,其中k为满足j\not=y_j且v_{i,j}-v_{i,y_i}+1\geq0的j的个数\\0,j\not=y_i且v_{i,j}-v_{i,y_i}+1<0\\1,j\not=y_j且v_{i,j}-v_{i,y_i}+1\geq0\end{cases}</script><p>当然，在真正的应用中我们还应该注意加上正则化项。</p>
<h2 id="具体的代码实现"><a href="#具体的代码实现" class="headerlink" title="具体的代码实现"></a>具体的代码实现</h2><p>有了上述的介绍，我们可以完成本次作业的代码了。</p>
<h3 id="linear-svm-py"><a href="#linear-svm-py" class="headerlink" title="linear_svm.py"></a>linear_svm.py</h3><p>直接完成第一个方法，用多层循环的方式完成loss与gradients的计算。</p>
<p>给出输入和输出：</p>
<p>Inputs:</p>
<ul>
<li>W: A numpy array of shape (D, C) containing weight.</li>
<li>X: A numpy array of shape (N, D) containing a minibatch of data.</li>
<li>y: A numpy array of shape (N, ) containing training labels; y[i] = c means that X[i] has label c, where 0 &lt;= c &lt; C</li>
</ul>
<p>Return:</p>
<ul>
<li>loss: a single float.</li>
<li>dW: a numpy array of gradients with respect to weights W.</li>
</ul>
<p>完成.svm_loss_naive():</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">svm_loss_naive</span><span class="params">(W, X, y, reg)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    dW = np.zeros_like(W) <span class="comment"># initialize the gradients as zeros</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    loss = <span class="number">0.0</span> <span class="comment"># initialize loss</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    num_classes = W.shape[<span class="number">1</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    num_train = X.shape[<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_train):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        scores = X[i].dot(W)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        correct_class_score = scores[y[i]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(num_classes):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> j == y[i]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">continue</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            margin = scores[j] - correct_class_score + <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> margin &gt; <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                loss += margin</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    loss = loss/num_train + reg*np.sum(W*W)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_train):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        scores = X[i].dot(W)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        correct_class_score = scores[y[i]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(num_classes):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> j==y[i]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">continue</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            margin = scores[j] - correct_class_score + <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> margin &gt; <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                dW[:, j] += X[i].T</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                dW[:, y[i]] -= X[i].T</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    dW = dW/num_train + <span class="number">2</span>*reg*W</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> loss, dW</span></pre></td></tr></table></figure>
<p>接下来可以用矢量化的方式完成方法.svm_loss_vectorized():</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">svm_loss_vectorized</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    dW = np.zeros_like(W) <span class="comment"># initialize the gradients as zeros.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    loss = <span class="number">0.0</span> <span class="comment"># initialize the loss</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    num_train = X.shape[<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    scores = X.dot(W)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    margin = scores - scores[np.arange(num_train), y][:, <span class="literal">None</span>] + <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    margin[margin&lt;<span class="number">0</span>] = <span class="number">0.0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    margin[np.arange(num_train), y] = <span class="number">0.0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    loss = np.sum(margin)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    loss = loss/num_train + reg*np.sum(W*W)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    dscores = np.zeros_like(scores)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    dscores[margin&gt;<span class="number">0</span>] = <span class="number">1.0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    dscores[np.arange(num_train), y] -= np.sum(dscores, axis=<span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    dW = np.dot(X.T, dscores)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    dW = dW/num_train + <span class="number">2</span>*reg*W</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> loss, dW</span></pre></td></tr></table></figure>
<h3 id="svm-ipynb"><a href="#svm-ipynb" class="headerlink" title="svm.ipynb"></a>svm.ipynb</h3><p>最后是寻找最佳参数的过程，可以参见另一篇博文《CS231N-Softmax》的最后部分，操作是完全一样的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然如今SVM已经不是机器学习中应用最广泛的方法了，但是这仍然是十分有意义的尝试与学习。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/08/CS231N-Assignment1-Softmax/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="陈蔚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吃完的贝壳">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/08/CS231N-Assignment1-Softmax/" class="post-title-link" itemprop="url">CS231N-Assignment1-Softmax</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-08 12:44:49" itemprop="dateCreated datePublished" datetime="2020-02-08T12:44:49+08:00">2020-02-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-12 11:28:59" itemprop="dateModified" datetime="2020-02-12T11:28:59+08:00">2020-02-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/CS231N/" itemprop="url" rel="index">
                    <span itemprop="name">CS231N</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CS231N-Softmax"><a href="#CS231N-Softmax" class="headerlink" title="CS231N-Softmax"></a>CS231N-Softmax</h1><blockquote>
<p>Softmax是CS231N中Assignment1的第三个习题。顾名思义，softmax由两个单词——soft和max——组成，即可以理解为一种max函数的变体。</p>
<p>本次练习的重点在于了解softmax的定义和基本使用。</p>
</blockquote>
<h2 id="Softmax的定义与损失函数"><a href="#Softmax的定义与损失函数" class="headerlink" title="Softmax的定义与损失函数"></a>Softmax的定义与损失函数</h2><p>假设有一个数组$V=(v_1,v_2,\dots,v_n)$，并用$v_i$表示数组$V$中的第i个元素的值，从而这个元素对应的softmax值为：</p>
<script type="math/tex; mode=display">S_i=\frac{e^{v_i}}{\displaystyle\sum_{k}{e^{v_k}}}</script><p>即为该元素的指数与所有元素的指数和的比值。这样，显见某数组所有元素的softmax值的和为1，即可以理解为一种概率的变体。</p>
<p>在此基础上，我们进一步定义softmax函数下的损失函数，假设一共使用了$m$个训练样本，其中第$i$个训练样本的对$i$个类别的得分分别为$(v_{i,1},v_{i,2},\dots,v_{i,n})$，其对第$j$个类别的softmax值为$S_{i, j}$，其标签类别为$y_i$，（特别要注意上下定义中符号的区别）：</p>
<script type="math/tex; mode=display">Loss=-\displaystyle\sum_{i=1}^{m}{1(j=y_i)ln(S_{i, j})}</script><p>有了以上基础之后，我们要进行的是一个难点：梯度的计算。</p>
<p>这里对于第$i$个训练样本要计算每一个$v_{i,j}$的梯度值，需要分两种情况$j=y_i$和$j\not=y_i$来进行讨论，首先是第一种情况：</p>
<script type="math/tex; mode=display">\begin{aligned}
\frac{\partial Loss}{\partial v_{i,j}}&=-\left[ln\left(\frac{e^{v_{i,j}}}{\displaystyle\sum_{k}{e^{v_{i,k}}}}\right)\right]'=-[v_{i,j}+ln(\displaystyle\sum_{k}{e^{v_{i,k}}})]'\\
&=-1+\frac{1}{\displaystyle\sum_{k}{e^{v_{i,k}}}} \times e^{v_{i,j}}\\
&=S_{i,j}-1
\end{aligned}</script><p>然后是第二种情况类似可以求得梯度为：</p>
<script type="math/tex; mode=display">
\frac{\partial Loss}{\partial v_{i,j}}=S_{i,j}</script><p>当然，在真正的应用中我们还应该注意加上正则化项。</p>
<h2 id="具体的代码实现"><a href="#具体的代码实现" class="headerlink" title="具体的代码实现"></a>具体的代码实现</h2><p>有了上述的介绍与偏微分的计算，在熟悉numpy操作的基础上，代码其实已经是很简单的事情了。同样地，本练习要求用循环与矢量化两种形式计算softmax以比较两种运算方式的速度差异。唯一与上述有所不同的地方在于上述的得分需要用一个affine层计算的出，所以还需要用链式法则计算出最后需要的输出。</p>
<h3 id="softmax-py"><a href="#softmax-py" class="headerlink" title="softmax.py"></a>softmax.py</h3><p>照例首先是已经给出的调用部分：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> builtins <span class="keyword">import</span> range</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> shuffle</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> past.builtins <span class="keyword">import</span> xrange</span></pre></td></tr></table></figure>
<p>然后指出函数要求的输入与输出：</p>
<p>Inputs:</p>
<ul>
<li>W: A numpy array of shape (D, C) containing weights.</li>
<li>X: A numpy array of shape (N, D) containing a minibatch of data.</li>
<li>y: A numpy array of shape (N, ) containing training labels; y[i] = c means that X[i, :] has label c, where 0 &lt;= c &lt;= C.</li>
<li>reg: (float) regularization strength.</li>
</ul>
<p>Return:</p>
<ul>
<li>loss: a single float.</li>
<li>dW: a numpy array of shape (D, C) containing the gradients with respect to the weights W.</li>
</ul>
<p>接下来完成要求的第一个方法.softmax_loss_naive():</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax_loss_naive</span><span class="params">(W, X, y, reg)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    loss = <span class="number">0.0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    dW = np.zeros_like(W) <span class="comment"># initialize the result</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    num_train = X.shape[<span class="number">0</span>] <span class="comment"># number of training examples</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    num_classes = W.shape[<span class="number">1</span>] <span class="comment"># number of classes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(C):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        scores = X[i, :].dot(W)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        exp = np.exp(scores)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        softmax = exp/np.sum(exp)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        loss += -np.log(softmax[y[i]])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(num_classes):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            dW[:, j] += X[i, :].T*softmax[j]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        dW[:, y[i]] -= X[i, :].T</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    loss = loss/num_train + <span class="number">0.5</span>*reg*np.sum(W*W)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    dW = dW/num_train + reg*W</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> loss, dW</span></pre></td></tr></table></figure>
<p>确认过正确性之后，我们可以用矢量化的方式完成同样的计算:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax_loss_vectorized</span><span class="params">(W, X, y, reg)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    loss = <span class="number">0.0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    dW = np.zeros_like(W)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    num_train = X.shape[<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    scores = X.dot(W)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    softmax = np.exp(scores)/np.sum(np.exp(scores), axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    loss = -np.sum(np.log(softmax[np.arange(num_train), y]))/num_train + <span class="number">0.5</span>*reg*np.sum(W*W)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    softmax[np.arange(num_train), y] -= <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    dW = np.dot(X.T, softmax)/num_train + reg*W</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> loss, dW</span></pre></td></tr></table></figure>
<h3 id="softmax-ipynb"><a href="#softmax-ipynb" class="headerlink" title="softmax.ipynb"></a>softmax.ipynb</h3><p>最后挑选合适的learning_rate和regularization_strength即可，这里用到了numpy的一个随机数函数np.random.uniform()，这里为了节省时间，每个模型只训练了100遍，当发现最佳的learing_rate和regularization_strength后，可以增加迭代的次数，最后可以得到一个比较好的可视结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cs231n.classifiers <span class="keyword">import</span> Softmax</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">results = &#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">best_val = <span class="number">-1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">best_softmax = <span class="literal">None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    lr = <span class="number">10</span>**np.random.uniform(<span class="number">-5</span>, <span class="number">-6</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    reg = <span class="number">10</span>**np.random.uniform(<span class="number">4</span>, <span class="number">5</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    softmax = Softmax()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    softmax.train(X_train, y_train, lr, reg, <span class="number">100</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    y_train_pred = softmax.predict(X_train)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    tra_accu = np.mean( y_train_pred==y_train )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    y_val_pred = softmax.predict(X_val)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    val_accu = np.mean( y_val_pred==y_val )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    results[(lr, reg)] = (tra_accu, val_accu)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> val_accu&gt;best_val:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        best_val = val_accu</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        best_softmax = softmax</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> lr, reg <span class="keyword">in</span> sorted(results):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    train_accuracy, val_accuracy = results[(lr, reg)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    print(<span class="string">'lr %e reg %e train accuracy: %f val accuracy: %f'</span> % (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">                lr, reg, train_accuracy, val_accuracy))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">print(<span class="string">'best validation accuracy achieved during cross-validation: %f'</span> % best_val)</span></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来讲，这次作业的难度不是那么大，唯一需要注意的地方就是梯度的求法与链式法则的运用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/08/C%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="陈蔚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吃完的贝壳">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/08/C%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8/" class="post-title-link" itemprop="url">C语言运算符优先级表</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-08 13:35:34 / 修改时间：13:37:58" itemprop="dateCreated datePublished" datetime="2020-01-08T13:35:34+08:00">2020-01-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">C语言</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <div class="table-box"><table border="1" cellspacing="0" cellpadding="0"><tbody><tr><td>
            <p>优先级</p>
            </td>
            <td>
            <p>运算符</p>
            </td>
            <td>
            <p>名称或含义</p>
            </td>
            <td>
            <p>使用形式</p>
            </td>
            <td>
            <p>结合方向</p>
            </td>
            <td>
            <p>说明</p>
            </td>
        </tr><tr><td rowspan="4">
            <p>1</p>
            </td>
            <td>
            <p>[]</p>
            </td>
            <td>
            <p>数组下标</p>
            </td>
            <td>
            <p>数组名[常量表达式]</p>
            </td>
            <td rowspan="4">
            <p>左到右</p>
            </td>
            <td>
            <p>--</p>
            </td>
        </tr><tr><td>
            <p>()</p>
            </td>
            <td>
            <p>圆括号</p>
            </td>
            <td>
            <p>(表达式）/函数名(形参表)</p>
            </td>
            <td>
            <p>--</p>
            </td>
        </tr><tr><td>
            <p>.</p>
            </td>
            <td>
            <p>成员选择（对象）</p>
            </td>
            <td>
            <p>对象.成员名</p>
            </td>
            <td>
            <p>--</p>
            </td>
        </tr><tr><td>
            <p>-&gt;</p>
            </td>
            <td>
            <p>成员选择（指针）</p>
            </td>
            <td>
            <p>对象指针-&gt;成员名</p>
            </td>
            <td>
            <p>--</p>
            </td>
        </tr><tr><td rowspan="9">
            <p>2</p>
            </td>
            <td>
            <p>-</p>
            </td>
            <td>
            <p>负号运算符</p>
            </td>
            <td>
            <p>-表达式</p>
            </td>
            <td rowspan="9">
            <p>右到左</p>
            </td>
            <td rowspan="7">
            <p>单目运算符</p>
            </td>
        </tr><tr><td>
            <p>~</p>
            </td>
            <td>
            <p>按位取反运算符</p>
            </td>
            <td>
            <p>~表达式</p>
            </td>
        </tr><tr><td>
            <p>++</p>
            </td>
            <td>
            <p>自增运算符</p>
            </td>
            <td>
            <p>++变量名/变量名++</p>
            </td>
        </tr><tr><td>
            <p>--</p>
            </td>
            <td>
            <p>自减运算符</p>
            </td>
            <td>
            <p>--变量名/变量名--</p>
            </td>
        </tr><tr><td>
            <p>*</p>
            </td>
            <td>
            <p>取值运算符</p>
            </td>
            <td>
            <p>*指针变量</p>
            </td>
        </tr><tr><td>
            <p>&amp;</p>
            </td>
            <td>
            <p>取地址运算符</p>
            </td>
            <td>
            <p>&amp;变量名</p>
            </td>
        </tr><tr><td>
            <p>!</p>
            </td>
            <td>
            <p>逻辑非运算符</p>
            </td>
            <td>
            <p>!表达式</p>
            </td>
        </tr><tr><td>
            <p>(类型)</p>
            </td>
            <td>
            <p>强制类型转换</p>
            </td>
            <td>
            <p>(数据类型)表达式</p>
            </td>
            <td>
            <p>--</p>
            </td>
        </tr><tr><td>
            <p>sizeof</p>
            </td>
            <td>
            <p>长度运算符</p>
            </td>
            <td>
            <p>sizeof(表达式)</p>
            </td>
            <td>
            <p>--</p>
            </td>
        </tr><tr><td rowspan="3">
            <p>3</p>
            </td>
            <td>
            <p>/</p>
            </td>
            <td>
            <p>除</p>
            </td>
            <td>
            <p>表达式/表达式</p>
            </td>
            <td rowspan="3">
            <p>左到右</p>
            </td>
            <td rowspan="3">
            <p>双目运算符</p>
            </td>
        </tr><tr><td>
            <p>*</p>
            </td>
            <td>
            <p>乘</p>
            </td>
            <td>
            <p>表达式*表达式</p>
            </td>
        </tr><tr><td>
            <p>%</p>
            </td>
            <td>
            <p>余数（取模）</p>
            </td>
            <td>
            <p>整型表达式%整型表达式</p>
            </td>
        </tr><tr><td rowspan="2">
            <p>4</p>
            </td>
            <td>
            <p>+</p>
            </td>
            <td>
            <p>加</p>
            </td>
            <td>
            <p>表达式+表达式</p>
            </td>
            <td rowspan="2">
            <p>左到右</p>
            </td>
            <td rowspan="2">
            <p>双目运算符</p>
            </td>
        </tr><tr><td>
            <p>-</p>
            </td>
            <td>
            <p>减</p>
            </td>
            <td>
            <p>表达式-表达式</p>
            </td>
        </tr><tr><td rowspan="2">
            <p>5</p>
            </td>
            <td>
            <p>&lt;&lt;&nbsp;</p>
            </td>
            <td>
            <p>左移</p>
            </td>
            <td>
            <p>变量&lt;&lt;表达式</p>
            </td>
            <td rowspan="2">
            <p>左到右</p>
            </td>
            <td rowspan="2">
            <p>双目运算符</p>
            </td>
        </tr><tr><td>
            <p>&gt;&gt;&nbsp;</p>
            </td>
            <td>
            <p>右移</p>
            </td>
            <td>
            <p>变量&gt;&gt;表达式</p>
            </td>
        </tr><tr><td rowspan="4">
            <p>6</p>
            </td>
            <td>
            <p>&gt;&nbsp;</p>
            </td>
            <td>
            <p>大于</p>
            </td>
            <td>
            <p>表达式&gt;表达式</p>
            </td>
            <td rowspan="4">
            <p>左到右</p>
            </td>
            <td rowspan="4">
            <p>双目运算符</p>
            </td>
        </tr><tr><td>
            <p>&gt;=</p>
            </td>
            <td>
            <p>大于等于</p>
            </td>
            <td>
            <p>表达式&gt;=表达式</p>
            </td>
        </tr><tr><td>
            <p>&lt;&nbsp;</p>
            </td>
            <td>
            <p>小于</p>
            </td>
            <td>
            <p>表达式&lt;表达式</p>
            </td>
        </tr><tr><td>
            <p>&lt;=</p>
            </td>
            <td>
            <p>小于等于</p>
            </td>
            <td>
            <p>表达式&lt;=表达式</p>
            </td>
        </tr><tr><td rowspan="2">
            <p>7</p>
            </td>
            <td>
            <p>==</p>
            </td>
            <td>
            <p>等于</p>
            </td>
            <td>
            <p>表达式==表达式</p>
            </td>
            <td rowspan="2">
            <p>左到右</p>
            </td>
            <td rowspan="2">
            <p>双目运算符</p>
            </td>
        </tr><tr><td>
            <p>！=</p>
            </td>
            <td>
            <p>不等于</p>
            </td>
            <td>
            <p>表达式!= 表达式</p>
            </td>
        </tr><tr><td>
            <p>8</p>
            </td>
            <td>
            <p>&amp;</p>
            </td>
            <td>
            <p>按位与</p>
            </td>
            <td>
            <p>表达式&amp;表达式</p>
            </td>
            <td>
            <p>左到右</p>
            </td>
            <td>
            <p>双目运算符</p>
            </td>
        </tr><tr><td>
            <p>9</p>
            </td>
            <td>
            <p>^</p>
            </td>
            <td>
            <p>按位异或</p>
            </td>
            <td>
            <p>表达式^表达式</p>
            </td>
            <td>
            <p>左到右</p>
            </td>
            <td>
            <p>双目运算符</p>
            </td>
        </tr><tr><td>
            <p>10</p>
            </td>
            <td>
            <p>|</p>
            </td>
            <td>
            <p>按位或</p>
            </td>
            <td>
            <p>表达式|表达式</p>
            </td>
            <td>
            <p>左到右</p>
            </td>
            <td>
            <p>双目运算符</p>
            </td>
        </tr><tr><td>
            <p>11</p>
            </td>
            <td>
            <p>&amp;&amp;</p>
            </td>
            <td>
            <p>逻辑与</p>
            </td>
            <td>
            <p>表达式&amp;&amp;表达式</p>
            </td>
            <td>
            <p>左到右</p>
            </td>
            <td>
            <p>双目运算符</p>
            </td>
        </tr><tr><td>
            <p>12</p>
            </td>
            <td>
            <p>||</p>
            </td>
            <td>
            <p>逻辑或</p>
            </td>
            <td>
            <p>表达式||表达式</p>
            </td>
            <td>
            <p>左到右</p>
            </td>
            <td>
            <p>双目运算符</p>
            </td>
        </tr><tr><td>
            <p>13</p>
            </td>
            <td>
            <p>?:</p>
            </td>
            <td>
            <p>条件运算符</p>
            </td>
            <td>
            <p>表达式1?</p>
            <p>表达式2: 表达式3</p>
            </td>
            <td>
            <p>右到左</p>
            </td>
            <td>
            <p>三目运算符</p>
            </td>
        </tr><tr><td rowspan="11">
            <p>14</p>
            </td>
            <td>
            <p>=</p>
            </td>
            <td>
            <p>赋值运算符</p>
            </td>
            <td>
            <p>变量=表达式</p>
            </td>
            <td rowspan="11">
            <p>右到左</p>
            </td>
            <td>
            <p>--</p>
            </td>
        </tr><tr><td>
            <p>/=</p>
            </td>
            <td>
            <p>除后赋值</p>
            </td>
            <td>
            <p>变量/=表达式</p>
            </td>
            <td>
            <p>--</p>
            </td>
        </tr><tr><td>
            <p>*=</p>
            </td>
            <td>
            <p>乘后赋值</p>
            </td>
            <td>
            <p>变量*=表达式</p>
            </td>
            <td>
            <p>--</p>
            </td>
        </tr><tr><td>
            <p>%=</p>
            </td>
            <td>
            <p>取模后赋值</p>
            </td>
            <td>
            <p>变量%=表达式</p>
            </td>
            <td>
            <p>--</p>
            </td>
        </tr><tr><td>
            <p>+=</p>
            </td>
            <td>
            <p>加后赋值</p>
            </td>
            <td>
            <p>变量+=表达式</p>
            </td>
            <td>
            <p>--</p>
            </td>
        </tr><tr><td>
            <p>-=</p>
            </td>
            <td>
            <p>减后赋值</p>
            </td>
            <td>
            <p>变量-=表达式</p>
            </td>
            <td>
            <p>--</p>
            </td>
        </tr><tr><td>
            <p>&lt;&lt;=</p>
            </td>
            <td>
            <p>左移后赋值</p>
            </td>
            <td>
            <p>变量&lt;&lt;=表达式</p>
            </td>
            <td>
            <p>--</p>
            </td>
        </tr><tr><td>
            <p>&gt;&gt;=</p>
            </td>
            <td>
            <p>右移后赋值</p>
            </td>
            <td>
            <p>变量&gt;&gt;=表达式</p>
            </td>
            <td>
            <p>--</p>
            </td>
        </tr><tr><td>
            <p>&amp;=</p>
            </td>
            <td>
            <p>按位与后赋值</p>
            </td>
            <td>
            <p>变量&amp;=表达式</p>
            </td>
            <td>
            <p>--</p>
            </td>
        </tr><tr><td>
            <p>^=</p>
            </td>
            <td>
            <p>按位异或后赋值</p>
            </td>
            <td>
            <p>变量^=表达式</p>
            </td>
            <td>
            <p>--</p>
            </td>
        </tr><tr><td>
            <p>|=</p>
            </td>
            <td>
            <p>按位或后赋值</p>
            </td>
            <td>
            <p>变量|=表达式</p>
            </td>
            <td>
            <p>--</p>
            </td>
        </tr><tr><td>
            <p>15</p>
            </td>
            <td>
            <p>，</p>
            </td>
            <td>
            <p>逗号运算符</p>
            </td>
            <td>
            <p>表达式,表达式,…</p>
            </td>
            <td>
            <p>左到右</p>
            </td>
            <td>
            <p>--</p>
            </td>
        </tr></tbody></table></div>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/03/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="陈蔚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吃完的贝壳">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/03/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" class="post-title-link" itemprop="url">归并排序与快速排序</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-03 13:43:04 / 修改时间：15:22:17" itemprop="dateCreated datePublished" datetime="2020-01-03T13:43:04+08:00">2020-01-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index">
                    <span itemprop="name">C语言</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C语言实现归并排序与快速排序"><a href="#C语言实现归并排序与快速排序" class="headerlink" title="C语言实现归并排序与快速排序"></a>C语言实现归并排序与快速排序</h1><blockquote>
<p>要考试了，这里实现一下比较有意思的两种排序方法：归并排序与快速排序；</p>
</blockquote>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>首先我们应该知道归并排序有两种实现方式，即自下而上与自上而下。这里完成分别的实现。</p>
<p>归并排序的基本原理是将所要排序的数组进行不断地二分，直到形成每两个一组的情况；然后，依次完成排序。这样子排序的时间复杂度为 <strong>O(N*log N)</strong> ，当N非常大时，归并排序比选择排序和冒泡排序都要快很多。</p>
<h3 id="归并排序自下而上的实现"><a href="#归并排序自下而上的实现" class="headerlink" title="归并排序自下而上的实现"></a>归并排序自下而上的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">这里实现两个函数：sort和merge</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">sort的作用是将需要排序的数列分成两个二分的数列</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">merge的作用是将两个小数列重新排列成符合顺序的大数列</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> a1[], <span class="keyword">int</span> a2[], <span class="keyword">int</span> len1, <span class="keyword">int</span> len2)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> a[n];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    sort(a, len1, len2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> len1 = n/<span class="number">2</span>, len2 = n - len1;    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> a1[len1];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> a2[len2];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 划分成两个数列</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++) a1[i] = a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len2;i++) a2[i] = a[len1 + i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    sort(a1, len1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    sort(a2, len2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 重新合并为一个数列</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    merge(a, a1, a2, len1, len2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> a1[], <span class="keyword">int</span> a2[], <span class="keyword">int</span> len1, <span class="keyword">int</span> len2)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> t1 = <span class="number">0</span>; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> t2 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> len = len1 + len2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len&amp;&amp;t1&lt;len1&amp;&amp;t2&lt;len2;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(a1[t1]&lt;a2[t2]) a[i] = a1[t1++];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span> a[i] = a2[t2++];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 可能已经遍历完a1或a2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=t1;i&lt;len1;i++) a[i+t2] = a1[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=t2;i&lt;len2;i++) a[i+t1] = a2[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="归并排序自上而下的实现"><a href="#归并排序自上而下的实现" class="headerlink" title="归并排序自上而下的实现"></a>归并排序自上而下的实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">观察上面一种自上而下的实现方法，我们会发现实际上数据本来就是独立的，之前的划分步骤或许可以省略</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">于是就有了以下的这种自下而上的实现，即直接对开始merge</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">当然这种情况其实并没有我一开始想象地那么简单，因为还有比较麻烦的边界条件需要处理</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">*/</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> i)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> mid)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> a[n];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    sort(a, n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 我们需要从最小的数组长度开始处理，直到最后，i的意义是每一次merge所需要小数组的长度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i*=<span class="number">2</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        divide(a, len, i);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len, <span class="keyword">int</span> gap)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// group代表每两个小数组合成大数组最后的长度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> group = <span class="number">2</span>*gap;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i+group<span class="number">-1</span>&lt;len;i+=group)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        merge(a, i, i+group<span class="number">-1</span>, i+gap<span class="number">-1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 最后需要处理最后还未排好的边界条件</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(i+gap<span class="number">-1</span>&lt;len<span class="number">-1</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">        merge(a, i , len<span class="number">-1</span>, i+gap<span class="number">-1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> mid)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// start表示归并开始的地方，mid表示第一个小数列的末尾，end表示第二个小数列的末尾</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(start&gt;=<span class="built_in">end</span>||mid&gt;=<span class="built_in">end</span>) <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> p1=start, p2=mid+<span class="number">1</span>, p=<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> *temp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(<span class="built_in">end</span>-start+<span class="number">1</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(p1&lt;=mid&amp;&amp;p2&lt;=<span class="built_in">end</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(a[p1]&lt;a[p2]) temp[p++] = a[p1++];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span> temp[p++] = a[p2++];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(p1&lt;=mid) temp[p++] = a[p1++];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(p2&lt;=<span class="built_in">end</span>) temp[p++] = a[p2++];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 从这里我们可以看出两种归并算法并无速度上的本质差别</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=<span class="built_in">end</span>;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">        a[i] = temp[i-start];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 最后要free掉申请的动态内存，养成良好的编程习惯</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">free</span>(temp);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序算法的基本想法类似于归并排序：</p>
<p>算法要求每一次将数列根据一个pivot划分为两个小数列，满足pivot左边的数都小于pivot，同时pivot右边的数都大于pivot。如此反复操作，直到小数列只有一个数时停止。因此，在快速排序的程序里肯定会有递归想法的运用。</p>
<p>容易知道，快速排序在最佳情况下的速度和归并排序一样。</p>
<p>同样地，快速排序也有两种比较基本的实现方法，他们的区别在于将数列划分成两个小数列的方法不同，下面给出分别的实现：</p>
<h3 id="快速排序的第一种实现方式"><a href="#快速排序的第一种实现方式" class="headerlink" title="快速排序的第一种实现方式"></a>快速排序的第一种实现方式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> a[n];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    sort(a, <span class="number">0</span>, n<span class="number">-1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(start&gt;=<span class="built_in">end</span>) <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i=start, j=<span class="built_in">end</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 以末尾的数作为pivot</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(a[i]&gt;a[j])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">int</span> temp = a[j];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            a[j] = a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            a[i] = a[j<span class="number">-1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            a[j<span class="number">-1</span>] = temp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">            j--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">            i++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    sort(a, start, i<span class="number">-1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    sort(a, i+<span class="number">1</span>, <span class="built_in">end</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>当然，这种实现方法还有一种比较聪明的方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> a[n];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    sort(a, <span class="number">0</span>, n<span class="number">-1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(start&gt;=<span class="built_in">end</span>) <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i = start;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> pivot = a[<span class="built_in">end</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=start;j&lt;<span class="built_in">end</span>;j++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(a[j]&lt;pivot)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 每次交换后，保证i左边的所有数都比pivot小，i及i右边的所有数都大于或者等于pivot</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">int</span> temp = a[j];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            a[j] = a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            a[i] = temp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">            i++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 最后交换a[i]与pivot的位置，就达到了用pivot划分数列的目的</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> temp = a[<span class="built_in">end</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    a[<span class="built_in">end</span>] = a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    a[i] = temp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    sort(a, start, i<span class="number">-1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    sort(a, i+<span class="number">1</span>, <span class="built_in">end</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="快速排序的第二种实现方式"><a href="#快速排序的第二种实现方式" class="headerlink" title="快速排序的第二种实现方式"></a>快速排序的第二种实现方式</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> a[n];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    sort(a, <span class="number">0</span>, n<span class="number">-1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(start&gt;=<span class="built_in">end</span>) <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    srand(time(<span class="literal">NULL</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 利用随机数选取pivot，至少不会让结果太差，虽然也不一定会很好</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> <span class="built_in">random</span> = rand()%(<span class="built_in">end</span>-start) + start;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> pivot = a[<span class="built_in">random</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i = start<span class="number">-1</span>, j = <span class="built_in">end</span>+<span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 寻找一对数，其中下标较小的数大于等于pivot，下标较大的数小于等于pivot</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 这样我们称其顺序正好颠倒，因此我们交换其位置</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">do</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            i++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        &#125;<span class="keyword">while</span>(a[i]&lt;pivot);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">do</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">            j--;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        &#125;<span class="keyword">while</span>(a[j]&gt;pivot);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(i&gt;=j) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> temp = a[j];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        a[j] = a[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        a[i] = temp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 循环结束后，保证j右边的数肯定是都大于pivot的，j及j左边的数小于等于pivot，完成划分</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    sort(a, start, j);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    sort(a, j+<span class="number">1</span>, <span class="built_in">end</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/21/CS231N-Assignment1-KNN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="陈蔚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吃完的贝壳">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/21/CS231N-Assignment1-KNN/" class="post-title-link" itemprop="url">CS231N-Assignment1-KNN</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-21 13:25:37" itemprop="dateCreated datePublished" datetime="2019-12-21T13:25:37+08:00">2019-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-19 13:15:13" itemprop="dateModified" datetime="2020-02-19T13:15:13+08:00">2020-02-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/CS231N/" itemprop="url" rel="index">
                    <span itemprop="name">CS231N</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CS231N-KNN"><a href="#CS231N-KNN" class="headerlink" title="CS231N-KNN"></a>CS231N-KNN</h1><blockquote>
<p>KNN是CS231N中Assignment1的第一个习题，是K_nearest_neighbours的简写。从理解上来说，KNN算法实际上就是简单地分别计算你的测试用例与各个训练用例之间的距离（范数？），从中取出距离最短的k个测试用例并依据他们的标签决定你的测试用例的标签。以下给出KNN算法的具体实现。</p>
<p>本次练习比较有趣的地方在于用循环嵌套、单层循环与numpy的broadcast机制分别实现距离的计算。 </p>
</blockquote>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>计算所有测试用例与训练用例之间的距离。</li>
<li>在给出这些距离的基础上，对每一个训练用例我们找到与其距离最短的k个用例，并用他们对标签进行投票。</li>
</ol>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="k-nearest-neighbor-py"><a href="#k-nearest-neighbor-py" class="headerlink" title="k_nearest_neighbor.py"></a>k_nearest_neighbor.py</h3><p>首先是一些题目中已经给出的必要准备</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> builtins <span class="keyword">import</span> range</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> builtins <span class="keyword">import</span> object</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> past.builtins <span class="keyword">import</span> xrange</span></pre></td></tr></table></figure>
<p>然后是用循环嵌套计算距离，用最简单的想法即可。先给出输入输出：</p>
<p>Inputs:</p>
<ul>
<li>X: A numpy array of shape (num_test, D) containing test data.</li>
</ul>
<p>Returns:</p>
<ul>
<li>dists: A numpy array of shape (num_test, num_train) where dists[i, j] is the Euclidean distance between the $i^{th}$ test point and the $j^{th}$ training point.</li>
</ul>
<p>完成方法.compute_two_loops():</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_two_loops</span><span class="params">(self, X)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    num_test = X.shape[<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    num_train = self.X_train.shape[<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    dists = np.zeros((num_test, num_train)) <span class="comment"># initialize the result</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_test):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(num_train):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            dist[i, j] = np.sum((X[i, :] - X_train[j, :])**<span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> dists</span></pre></td></tr></table></figure>
<p>之后我们需要预测测试用例的标签，先给出输入输出：</p>
<p>Inputs:</p>
<ul>
<li>dists: A numpy array defined above.</li>
<li>k: number of training point that will vote for the results.</li>
</ul>
<p>Returns:</p>
<ul>
<li>y_pred: A numpy array of shape(num_test, ) containing predicted labels for the test data, where y[i] is the predicted label for the test point X[i].</li>
</ul>
<p>完成方法.predict_labels():</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_labels</span><span class="params">(self, dists, k=<span class="number">1</span>)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    num_test = dists.shape[<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    y_pred = np.zeros(num_test) <span class="comment"># initialize the result</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_test):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        closest_y = [] <span class="comment"># A list of length k storing the labels of the k nearest neighbors to the ith test point.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        closest_y = self.y_train[np.argsort(dists[i, :])[:k]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        y_pred[i] = np.argmax(np.bincount(closest_y))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> y_pred</span></pre></td></tr></table></figure>
<p>上述过程我实在是懒得写循环，所以直接用了numpy的内置函数，这些函数的详情可以见我的另一篇博文《Numpy有关知识》，这里不再赘述。</p>
<p>做完上述步骤后，我们可以在CIFAR-10数据集上测试，得到接近27%的准确率，总归是比随机的10%要高一点的。</p>
<p>以下完成单层循环计算dists的方法.compute_distances_one_loop():</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_distances_one_loop</span><span class="params">(self, X)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    num_test = X.shape[<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    num_train = self.X_train.shape[<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    dists = np.zeros((num_test, num_train))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_test):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        dists[i, :] = np.sqrt(np.sum(np.square((self.X_train - X[i, :])), axis=<span class="number">1</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> dists</span></pre></td></tr></table></figure>
<p>最后是不使用循环的方法，这里需要用到公式$\sqrt{\sum(a-b)^2} = \sqrt{\sum(a^2+b^2-2ab)}$，即我们要将把L2范数用展开的方式计算，完成方法.compute_distance_no_loop()：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_distance_no_loop</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    num_test = X.shape[<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    num_train = self.X_train.shape[<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    dists = np.zeros((num_test, num_train))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    a_square = np.sum(np.square(X), axis=<span class="number">1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    b_square = np.sum(np.square(self.X_train), axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    ab = np.dot(X, self.X_train.T)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    dists = a_square + b_square - <span class="number">2</span>*ab</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    dists = np.sqrt(dists)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> dists</span></pre></td></tr></table></figure>
<p>运行后，我们发现用numpy的广播机制快得真的不是一点两点。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本次作业，我们熟悉了几个numpy中的常用函数，这是比较重要的。因为就KNN算法本身而言，它还是停留在直观层面上的一种原始算法，在真正的工程中很少会用到。更重要的一点是，我们希望的结果是在训练的时候可以多花一点时间以得到较好的结果，而在预测的时候要较快地得出结果，然而KNN算法的表现正好相反。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/21/NumPy%E6%9C%89%E5%85%B3%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="陈蔚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吃完的贝壳">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/21/NumPy%E6%9C%89%E5%85%B3%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">NumPy有关知识</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-21 13:24:21" itemprop="dateCreated datePublished" datetime="2019-12-21T13:24:21+08:00">2019-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-03 15:29:25" itemprop="dateModified" datetime="2020-01-03T15:29:25+08:00">2020-01-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="NumPy有关知识"><a href="#NumPy有关知识" class="headerlink" title="NumPy有关知识"></a>NumPy有关知识</h1><blockquote>
<p>最近正在学习CS231N的课程，还没有听具体内容。因为之前学习过吴恩达的机器学习课程，所以我想要先自己试试看Assignment1中的第一个作业（最简单的K nearest neighbors算法），没有想到，真正阻止我成功完成作业的并不是算法上不能理解，而是我真的不懂NumPy和Python的基本操作。</p>
<p>NumPy是Python中的一个用于进行科学计算的核心库。它在进行高维的array对象计算中，是十分有效率的。</p>
</blockquote>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><p>首先，我们可以用Python内置的list对象来初始化NumPy的array对象，并通过用方括号括起来的数来取出其中的数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创造一个一列的array对象，其类型为 &lt;class 'numpy.ndarray'&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创造一个多维的array对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">b = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其中，可以用 .shape[] 方法得到 b 对象各个维度的值，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># shape[0]返回第一维，以此类推，不标则对应所有维度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">print(b.shape)</span></pre></td></tr></table></figure>
<p>此外，NumPy还提供了一些创造array对象的函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下分别创造全零矩阵，全一矩阵，单位矩阵，每一个元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全部相等（可以自己给定）的矩阵</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">a = np.zeros((<span class="number">2</span>, <span class="number">2</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">b = np.ones((<span class="number">1</span>, <span class="number">2</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">c = np.full((<span class="number">2</span>, <span class="number">2</span>), <span class="number">7</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">d = np.eye(<span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">e = np.random.random((<span class="number">2</span>, <span class="number">2</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">y = np.empty_like(x)    <span class="comment"># 创造一个和x有相同大小的空矩阵</span></span></pre></td></tr></table></figure>
<p>之后，关于NumPy的下标问题，我们同样可以像对list对象一样使用切片等</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创造一个array对象，注意二维的时候对象是一个list，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 而list中的每一个元素又都是一个list</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">b = a[:<span class="number">2</span>, <span class="number">1</span>:<span class="number">3</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意这样得到的切片并不是一份拷贝而是同一个数据，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因此改变切片中的数据实际上也会改变本来的数据。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同样，数组可以混合使用整数下标和切片下标，但是混合使用时，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># array的维度会发生转变，因此，就算只用切片取出一列或一行最好也都使用切片</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">row_r1 = a[<span class="number">1</span>:<span class="number">2</span>, :]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以用两个array作为下标分别取出每一行中的对应元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">b = np.array([<span class="number">0</span> ,<span class="number">2</span>, <span class="number">3</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">print(a[np.arange(<span class="number">3</span>), b])</span></pre></td></tr></table></figure>
<p>我们选择使用array类型的原因是其比list高效且易操作，这里给出一些数学运算，需要在注意的是基本的数学运算在array类型中都是对array的各个元素分别做的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], dtype=np.float64)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">y = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], dtype=np.float64)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下分别演示矩阵的加、乘、开方等操作</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先是矩阵的相加、开方</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">print(x + y)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">print(np.add(x, y))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">print(np.sqrt(x))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩阵直接用乘号连接表达的意思是矩阵对应元素项的相乘</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">print(x * y)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">print(np.multiply(x, y))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向量、矩阵等的乘法的实现方式</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">print(x.dot(y))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">print(np.dot(x, y))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分别求矩阵的所有元素和、每一列元素和、每一行元素和</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">print(np.sum(x))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">print(np.sum(x, axis=<span class="number">0</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">print(np.sum(x, axis=<span class="number">1</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 还有简单的转置操作，这里要注意对向量的转置并没有使其发生变化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">print(x.T)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">v = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">print(v.T)      <span class="comment"># v没有发生变化</span></span></pre></td></tr></table></figure>
<p>以上，关于 <strong>axis</strong> 的意思，可以简单的理解为：使用0值表示沿着每一列向下执行方法；使用1值表示沿着每一行横向执行对应的方法。</p>
<p>以下需要补充一个NumPy中的一个极为重要的加速计算的操作：广播( <strong>Broadcasting</strong> )</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为广播的原因，v会被拷贝直到两者相等</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">y = x + v   <span class="comment"># == x + np.title(v, (4, 1))</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">w = np.array([<span class="number">4</span>, <span class="number">5</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">print(np.reshape(v, (<span class="number">3</span>, <span class="number">1</span>)) + w)</span></pre></td></tr></table></figure>
<p>补充我在写KNN时遇到的几个需要用的NumPy函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的这条表达式是找出所有训练点中与测试点距离最近的k个训练点的标签</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 特别地，argsort()函数的作用是将array对象中的所有元素按照从小到大的顺序进行排列</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">closet_y = self.y_train[np.argsort(dists[i, :])[:k]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的这条表达式作用是找出所有标签中出现次数最多的标签，并将这个标签赋给y_pred[i]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 特别地，bincount()的作用是计算从零到标签最大值（整数）之间各个数出现的次数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># argmax()——argmin()同理——返回在所求array对象中最大的元素的下标</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">y_pred[i] = np.argmax(np.bincount(closet_y))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 特别地，argmax()函数也可以加上参数axis，以下两条分别表示求每一列的最大值和每一行的最大值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">print(np.argmax(a, axis=<span class="number">0</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">print(np.argmax(a, axis=<span class="number">1</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面补充两个折磨了我很久的函数hstack()和vstack()，</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#作用是将两个array类型的对象拼接到一起。这两句的意思是</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将X_train_folds和y_train_folds中除了第i个以外的所有点合成训练集</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从而进行交叉验证(cross validation)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">X_tr = np.vstack(X_train_folds[:i] + X_train_folds[i+<span class="number">1</span>:])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">y_tr = np.hstack(y_train_folds[:i] + y_train_folds[i+<span class="number">1</span>:])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个更加正式的写法如下</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其中，vstack()的作用是将array对象拼接到不同维度上，按列方向堆叠</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># hstack()的作用是将array对象在同一维度上拼接，按行方向堆叠</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">print(np.vstack((a, b)))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">print(np.hstack((a, b)))</span></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/15/Octave-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="陈蔚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="吃完的贝壳">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/15/Octave-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">Octave 基本操作</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-12-15 18:13:27 / 修改时间：20:48:17" itemprop="dateCreated datePublished" datetime="2019-12-15T18:13:27+08:00">2019-12-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A8%8B/Machine-Learning/" itemprop="url" rel="index">
                    <span itemprop="name">Machine Learning</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Octave-基本操作"><a href="#Octave-基本操作" class="headerlink" title="Octave 基本操作"></a>Octave 基本操作</h1><blockquote>
<p>学习 Andrew Ng 的机器学习课程时，为了能够简化计算以在算法层面对 Machine Learning 有更深的了解，推荐使用了Octave或Matlab，笔者比较穷苦所以理所当然地选择了免费的Octave，这里记录了Octave的基本操作以免每次使用时都要一直百度。</p>
<p>以下</p>
</blockquote>
<h2 id="一、矩阵的基本操作"><a href="#一、矩阵的基本操作" class="headerlink" title="一、矩阵的基本操作"></a>一、矩阵的基本操作</h2><p>首先，Octave中的语句如果以 <strong>“;”</strong> 结尾则不会打印表达式的结果，否则每一步操作都会在屏幕上打印结果。</p>
<p>以下是关于矩阵A不涉及计算的基本操作</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>; <span class="number">3</span>, <span class="number">4</span>; <span class="number">5.</span> <span class="number">6</span>]; <span class="comment">% 生成3 x 2 阶矩阵A</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>(A); <span class="comment">% 返回矩阵A的行数与列数，先行后列，1 x 2阶矩阵</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>(A, <span class="number">1</span>); <span class="comment">% 返回矩阵A的第一维，即行数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">size</span>(A, <span class="number">2</span>); <span class="comment">% 返回矩阵A的第二维，即列数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">length</span>(A); <span class="comment">% 返回矩阵A的最大维度</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">A(<span class="number">3</span>, <span class="number">2</span>); <span class="comment">%取出矩阵A中第三行第二列的元素，这里注意Octave中取出元素用的是圆括号，并用逗号表示分隔</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">A(<span class="number">3</span>, :); <span class="comment">% 取出矩阵A中第三行的所有元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">A(:, <span class="number">1</span>); <span class="comment">% 取出矩阵A中第一列的所有元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">A([<span class="number">1</span> <span class="number">3</span>], :); <span class="comment">% 取出矩阵A中行数为1或3的所有元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">C = [A, B] <span class="comment">% 矩阵C表示将矩阵A，矩阵B左右相连</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">C = [A; B] <span class="comment">% 矩阵C表示将矩阵A，矩阵B上下相连</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">vectorA = A(:); <span class="comment">% 将A中的所有元素展开在一个列向量中</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">A = <span class="built_in">magic</span>(<span class="number">3</span>); <span class="comment">% 生成三行三列的幻方</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">A = <span class="built_in">rand</span>(<span class="number">3</span>); <span class="comment">% 生成3 x 3阶的随机数矩阵，范围在(0, 1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">E = <span class="built_in">eye</span>(<span class="number">3</span>); <span class="comment">% 生成3 x 3阶的单位矩阵</span></span></pre></td></tr></table></figure>
<h2 id="二、Octave文件等操作"><a href="#二、Octave文件等操作" class="headerlink" title="二、Octave文件等操作"></a>二、Octave文件等操作</h2><p>以下是关于Octave中的加载文件、显示路径等操作。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">pwd <span class="comment">% 返回当前Ovtave所处的路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">ls <span class="comment">% 列出当前路径下所有可以的路径</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">load featuresX.dat; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">load(<span class="string">'featuresX.dat'</span>); <span class="comment">% 加载名为features.dat的数据文件，并保存在名为featuresX的变量中</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">who <span class="comment">% 显示出当前Octave工作空间中的所有变量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">whos <span class="comment">% 更详细地显示出当前Octave工作空间中的所有变量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">clear featuresX; <span class="comment">% 可以清除变量featuresX</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">clear; <span class="comment">% 直接清除Octave工作空间中的所有变量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">save hello.mat featuresX; <span class="comment">% 将变量featuresX保存为文件hello.mat,此时如果重新加载文件则变量名为featuresX不变</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">save hello.txt featuresX -ascii; <span class="comment">% 将数据的ASCII码保存为文本文档</span></span></pre></td></tr></table></figure>
<h2 id="三、Octave中的各种运算"><a href="#三、Octave中的各种运算" class="headerlink" title="三、Octave中的各种运算"></a>三、Octave中的各种运算</h2><p>Octave中的各种运算是十分重要的，不了解的话对于向量化的运算影响很大。注意不同于C、python等语言，Octave中的下标是从1开始的而不是从0开始的。</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">C = A * B; <span class="comment">% 简单的矩阵相乘</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">C = A .* B; <span class="comment">% 矩阵中对应元素相乘</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">A = A .^<span class="number">2</span>; <span class="comment">% 得到将A中的所有元素平方的结果</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">A = <span class="number">1</span> ./ A； <span class="comment">% 得到将A中的所有元素的倒数的结果</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">logA = <span class="built_in">log</span>(A); <span class="comment">% 对矩阵A中的所有元素分别求以10为底</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">expA = <span class="built_in">exp</span>(A); <span class="comment">% 对矩阵A中的所有元素分别求以e为底的指数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">absA = <span class="built_in">abs</span>(A); <span class="comment">% 对矩阵A中的所有元素分别求绝对值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">lambdaA = lambda * A; <span class="comment">% 对矩阵A中的所有元素分别乘以lambda</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">plusA = A + lambda; <span class="comment">% 对矩阵A中的所有元素分别加上lambda</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">transA = A'; <span class="comment">% 取得A的转置矩阵</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">vector = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">[val, idx] = <span class="built_in">max</span>(vector); <span class="comment">% val得到向量vector中的最大值，idx得到最大值的下标。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>(vector &lt; <span class="number">3</span>); <span class="comment">% 返回vector中所有小于3的元素的下标</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">ProductOfVector = prod(vector); <span class="comment">% 返回vector中所有元素的乘积</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">A = [<span class="number">1</span>, <span class="number">2</span>; <span class="number">3</span>, <span class="number">4</span>; <span class="number">5</span>, <span class="number">6</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">ans</span> = A &lt; <span class="number">3</span>; <span class="comment">% 返回一个和A相同大小的矩阵，A中符合小于3的元素的对应位置上的数为1，不符合的位置上为0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">[r, c] = <span class="built_in">find</span>(A &lt;= <span class="number">3</span>); <span class="comment">% 返回两个列向量r, c，其中r包含A中不大于3的数的行数(row)，s包含A中不大于3的数的列数(column)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(A, [], <span class="number">1</span>); <span class="comment">% 返回A中每列的最大值，结果是一个行向量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(A, [], <span class="number">2</span>); <span class="comment">% 返回A中每行的最大值，结果是一个列向量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(A); <span class="comment">% 默认情况下是返回每列的最大值，即等价于max(A, [], 1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">MaxOfA = <span class="built_in">max</span>(A(:)); <span class="comment">% 返回矩阵A中的所有元素中的最大值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">SumOfColumn = sum(A, <span class="number">1</span>); <span class="comment">% 返回矩阵A中每一列元素的和，结果是一个行向量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">SumOfRow = sum(A, <span class="number">2</span>); <span class="comment">% 返回矩阵A中每一行元素的和，结果是一个列向量</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">ceilA = <span class="built_in">ceil</span>(A); <span class="comment">% 对A中的所有元素向上取整</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">floorA = <span class="built_in">floor</span>(A); <span class="comment">% 对A中的所有元素向下取整</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">Ainev = pinv(A); <span class="comment">% 返回A的逆矩阵</span></span></pre></td></tr></table></figure>
<h2 id="四、Octave中的循环控制"><a href="#四、Octave中的循环控制" class="headerlink" title="四、Octave中的循环控制"></a>四、Octave中的循环控制</h2><h2 id="五、其他重要的事情"><a href="#五、其他重要的事情" class="headerlink" title="五、其他重要的事情"></a>五、其他重要的事情</h2><p>开始做课程的编程作业后，笔者发现在自己的电脑上pause()函数并不能用（可能是安装路径中有乱码的中文），这里的解决方法是可以自己写一个pause函数放在作业的文件夹下。</p>
<p>下面贴出pause.m文件的代码：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pause</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">true</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    str = input(<span class="string">''</span>,<span class="string">'s'</span>); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">switch</span> str </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">case</span> <span class="string">''</span> <span class="comment">% (return key) </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">otherwise</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">end</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">end</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">end</span></span></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">陈蔚</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈蔚</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
